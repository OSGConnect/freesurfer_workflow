#!/usr/bin/env python
import argparse
import getpass
import hashlib
import httplib
import json
import os
import sys
import time
import urllib
import urlparse
import re

import cPickle

REST_ENDPOINT = "http://postgres.ci-connect.net/freesurfer"
VERSION = '1.3.2'
CREDENTIAL_FILE = os.path.expanduser('~/.fsurf/credentials')


def get_user_credentials():
    """
    Try to get user credentials from a file

    :return: username, password
    """
    if os.path.isfile(CREDENTIAL_FILE):
        with open(CREDENTIAL_FILE, 'rb') as f:
            try:
                pickle = cPickle.load(f)
                if type(pickle) == dict:
                    username = pickle['username']
                    password = pickle['password']
                    return username, password
                else:
                    sys.stdout.write("Credential file is invalid\n")
            except EOFError:
                sys.stdout.write("Credential file is invalid\n")
    return None, None


def save_user_credentials(username, password):
    """
    Try to save user credentials to a file

    :return: None
    """
    if get_user_response('Save credentials? '):
        try:
            cred_dict = {'username': username,
                         'password': password}
            cred_dir = os.path.dirname(CREDENTIAL_FILE)
            if not os.path.exists(cred_dir):
                os.mkdir(cred_dir)
            with open(CREDENTIAL_FILE, 'wb') as f:
                cPickle.dump(cred_dict, f, cPickle.HIGHEST_PROTOCOL)
        except OSError:
            sys.stdout.write("Can't save credentials to {0}\n".format(CREDENTIAL_FILE))
    return


def get_user_info(args):
    """
    Query user for username and password and return

    :param args: argparse object
    :return: username, password
    """
    if not args.user and not args.password:
        username, password = get_user_credentials()
        if username and password:
            return username, password

    if args.user:
        username = args.user
    else:
        username = raw_input("Enter username: ").strip()

    if args.password:
        password = args.password
    else:
        password = getpass.getpass("Enter password: ")
    save_user_credentials(username, password)
    return username, password


def get_user_response(prompt):
    """
    Give a prompt to the user and return a True/False based on user input

    :param prompt: Text to present to user
    :return: True if user said yes, False otherwise
    """
    response = ""
    while response not in ['y', 'n']:
        response = raw_input(prompt)
        response = response.strip().lower()

    if response == 'y':
        return True
    else:
        return False


def get_response(query_parameters, noun, method, endpoint=REST_ENDPOINT):
    """
    Query rest endpoint with given  string and return results

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :param method:  HTTP method that should be used
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.netloc)
        conn.request(method, "{0}?{1}".format(parsed.path, parsed.query))
        resp = conn.getresponse()
        return resp.status, resp.read()
    except IOError, e:  # mainly dns errors
        response = {'status': 500,
                    'result': str(e)}
        return 500, json.dumps(response)
    except httplib.HTTPException, e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def download_output(query_parameters, noun, endpoint=REST_ENDPOINT):
    """
    Query rest endpoint with given  string and return results

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request('GET', "{0}?{1}".format(parsed.path, parsed.query))
        resp = conn.getresponse()
        content_type = resp.getheader('content-type')
        if content_type != 'application/x-bzip2' and \
           content_type != 'text/plain':
            return resp.status, resp.read()
        content_disposition = resp.getheader('content-disposition')
        if content_type == 'application/x-bzip2':
            filename = 'fsurf_output.tar.bz2'
        elif content_type == 'text/plain':
            filename = 'recon-all.log'
        match_obj = re.search(r'filename=(.*)', content_disposition)
        if match_obj:
            filename = match_obj.group(1)
        with open(filename, 'wb') as f:
            temp = resp.read(4096)
            while temp:
                f.write(temp)
                temp = resp.read(4096)
        return resp.status, json.dumps({'status': 200,
                                        'result': "output downloaded",
                                        'filename': filename})
    except httplib.HTTPException, e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def upload_item(query_parameters, noun, body, method, endpoint=REST_ENDPOINT):
    """
    Issue a POST request to given endpoint

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :param body:  data to be sent in the body
    :param method:  HTTP method that should be used (POST, PUT)
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request(method, "{0}?{1}".format(parsed.path, parsed.query), body)
        resp = conn.getresponse()
        return resp.status, resp.read()
    except httplib.HTTPException, e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def get_token(userid, password):
    """
    Generate an authentication token and timestamp
    :param userid: user id identifying account
    :param password: password for user account
    :return: timestamp, token
    """
    parameters = {'userid': userid}
    code, response = get_response(parameters, 'user/salt', 'GET', REST_ENDPOINT)
    if code == 401:
        sys.stdout.write("User account disabled\n")
        return None, None
    elif code == 400:
        sys.stdout.write("Userid not found\n")
        return None, None
    timestamp = time.time()
    response_obj = json.loads(response)
    salt = response_obj['result']
    token = hashlib.sha256(salt + password).hexdigest()
    token = hashlib.sha256(token + str(timestamp)).hexdigest()
    return str(timestamp), token


def list_workflows(username, password, all=False):
    """
    List the workflows currently in the system

    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :param all:      whether to return all workflows or just the last 7 days
    :return: 0 on success, 1 on error
    """
    try:
        query_params = {}
        timestamp, token = get_token(username, password)
        if token is None:
            return 1
        query_params['userid'] = username
        query_params['timestamp'] = timestamp
        query_params['token'] = token
        query_params['all'] = all
        status, response = get_response(query_params, 'job', 'GET')
        if status != 200:
            sys.stdout.write("Error getting workflow information\n")
            return 1
        sys.stdout.write("Current workflows\n")
        response_object = json.loads(response)
        sys.stdout.write("{0:10} {1:20} {2:27} ".format('Subject',
                                                        'Workflow',
                                                        'Submit time'))
        sys.stdout.write("{0:10} {1:10}\n".format('Cores', 'Status'))
        if len(response_object['jobs']) == 0:
            sys.stdout.write("No workflows in system\n")
        for workflow in response_object['jobs']:
            job_id = workflow[0]
            subject = workflow[1]
            status = workflow[2]
            job_time = workflow[3]
            if not workflow[4]:
                cores = 2
            else:
                cores = 8

            sys.stdout.write("{0:10} {1:<20} {2:<27} ".format(subject,
                                                              job_id,
                                                              job_time))
            sys.stdout.write("{0:<10} {1:10}\n".format(cores,
                                                       status))
        return 0
    except IOError:
        return 1


def remove_workflow(workflow_id, username, password):
    """
    Stop and remove a specified pegasus workflow

    :param workflow_id: pegasus id for workflow
    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :return: 0 on success, 1 on error
    """
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = workflow_id
    status, response = get_response(query_params, 'job', 'DELETE')
    resp_dict = json.loads(response)
    if status != 200:
        sys.stdout.write("Error deleting "
                         "workflow:\n{0}\n".format(resp_dict['result']))
        return 1
    sys.stdout.write("Workflow removed\n")
    return 0


def submit_workflow(username, password, input_directory, subject_name,
                    multicore=False, deidentified=False, defaced=False):
    """
    Submit a workflow to OSG for processing

    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :param input_directory:    path to file with MRI data in mgz format
    :param subject_name:  name of subject in the file
    :param multicore:     boolean indicating whether to use a multicore workflow or not
    :param deidentified:  boolean indicating whether MRI image has been
                          deidentified
    :param defaced:       boolean indicating whether MRI image has been defaced
    :return:              0 on success, 1 on error
    """
    if subject_name is None:
        sys.stdout.write("Subject name is missing, exiting...\n")
        return 1
    if not deidentified:
        agree = get_user_response("Has the MRI data been deidentified "
                                  "(This is required) [y/n]? ")
        if not agree:
            sys.stdout.write("MRI data must be deidentified, please "
                             "deidentify the data before submitting\n")
            return 1
    if not defaced:
        agree = get_user_response("Has the MRI data been defaced "
                                  "(This is recommended) [y/n]? ")
        if not agree:
            sys.stdout.write("We recommend defacing MRI data\n")
            agree = get_user_response("Are you sure you want to submit this "
                                      "file [y/n]?")
            if not agree:
                sys.stdout.write("Aborting submission on user request\n")
                return 1
    subject_file = os.path.join(input_directory,
                                "{0}_defaced.mgz".format(subject_name))
    subject_file = os.path.abspath(subject_file)
    if not os.path.isfile(subject_file):
        sys.stderr.write("{0} is not present and is needed, exiting\n".format(subject_file))
        return 1
    with open(subject_file, 'rb') as f:
        body = f.read()
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['multicore'] = multicore
    query_params['subject'] = subject_name
    query_params['jobname'] = "{0}_{1}".format(subject_name, timestamp)
    query_params['filename'] = "{0}_defaced.mgz".format(subject_name)
    sys.stdout.write("Creating and submitting workflow\n")
    status, response = upload_item(query_params, 'job', body, 'POST')
    if status != 200:
        sys.stdout.write("Error while submitting workflow\n")
        return 1
    response_obj = json.loads(response)
    job_id = response_obj['job_id']
    sys.stdout.write("Workflow {0} submitted for processing\n".format(job_id))
    return 0


def get_output(workflow_id, username, password):
    """
    Get MRI data for a completed workflow

    :param workflow_id: pegasus id for workflow
    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :return: 0 on success, 1 on error
    """
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = workflow_id
    sys.stdout.write("Downloading results, this may take a while\n")
    status, response = download_output(query_params, 'job/output')
    response_obj = json.loads(response)
    if status != 200:
        sys.stdout.write("Error while downloading results:\n")
        sys.stdout.write("{0}\n".format(response_obj['result']))
        return 1
    sys.stdout.write("Downloaded to {0}\n".format(response_obj['filename']))
    sys.stdout.write("To extract the results: tar "
                     "xvjf {0}\n".format(response_obj['filename']))
    return 0


def get_log(workflow_id, username, password):
    """
    Get logs for a completed workflow

    :param workflow_id: pegasus id for workflow
    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :return: 0 on success, 1 on error
    """
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = workflow_id
    sys.stdout.write("Downloading logs, this may take a while\n")
    status, response = download_output(query_params, 'job/log')
    response_obj = json.loads(response)
    if status != 200:
        sys.stdout.write("Error while downloading logs:\n")
        sys.stdout.write("{0}\n".format(response_obj['result']))
        return 1

    sys.stdout.write("Downloaded to {0}\n".format(response_obj['filename']))
    return 0


def get_status(workflow_id, username, password):
    """
    Get status for a workflow

    :param workflow_id: pegasus id for workflow
    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :return: 0 on success, 1 on error
    """
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = workflow_id
    status, response = get_response(query_params,
                                    'job/status',
                                    'GET')
    response_obj = json.loads(response)
    if status == 404:
        sys.stdout.write("Workflow with id {0} not found\n".format(workflow_id))
        return 0
    elif status != 200:
        sys.stdout.write("Error while getting job status:\n")
        sys.stdout.write("{0}\n".format(response_obj['result']))
        return 1

    sys.stdout.write("{0}\n".format(response_obj['job_status']))
    return 0


def change_password(username, password):
    """
    Change the user's password

    :param username: username to use when authenticating
    :param password: password to user when authenticating
    :return: 0 on success, 1 on error
    """
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    new_password = getpass.getpass("Enter new password: ")
    tmp2 = getpass.getpass("Re-enter new password: ")
    if new_password != tmp2:
        sys.stdout.write("Passwords do not match, please try again.\n")
        return 1
    salt = hashlib.sha256(str(time.time())).hexdigest()
    pw_hash = hashlib.sha256(salt + password).hexdigest()

    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['salt'] = salt
    query_params['pw_hash'] = pw_hash
    status, response = get_response(query_params,
                                    'user/password',
                                    'PUT')
    response_obj = json.loads(response)
    if status == 401:
        sys.stdout.write("User not authorized to change password\n")
        return 0
    if status == 404:
        sys.stdout.write("User not found\n")
        return 0
    elif status != 200:
        sys.stdout.write("Error while changing password:\n")
        sys.stdout.write("{0}\n".format(response_obj['result']))
        return 1

    sys.stdout.write("{0}\n".format(response_obj['result']))
    return 0


def main():
    """
    Main function that parses arguments and generates the pegasus
    workflow

    :return: True if any errors occurred during DAX generaton
    """
    parser = argparse.ArgumentParser(description="Process freesurfer information")
    # version info
    parser.add_argument('--version', action='version', version='%(prog)s ' + VERSION)
    # Arguments for action
    parser.add_argument('--submit', dest='action',
                        action='store_const', const='submit',
                        help='Submit job for processing')
    parser.add_argument('--list', dest='action',
                        action='store_const', const='list',
                        help='List current jobs')
    parser.add_argument('--status', dest='action',
                        action='store_const', const='status',
                        help='Get status for specified job')
    parser.add_argument('--remove', dest='action',
                        action='store_const', const='remove',
                        help='Remove specified job')
    parser.add_argument('--output', dest='action',
                        action='store_const', const='output',
                        help='Download results for specified job')
    parser.add_argument('--log', dest='action',
                        action='store_const', const='log',
                        help="Get log file for specified job")
    parser.add_argument('--change-password', dest='action',
                        action='store_const', const='change_password',
                        help="Change the user password")
    # Arguments identifying workflow
    parser.add_argument('--id', dest='workflow_id',
                        action='store', help='Pegasus workflow id to use')
    # Arguments for list  action
    parser.add_argument('--all-workflows', dest='all_workflows',
                        action='store_true', help='List all workflows')
    # Arguments for submit action
    parser.add_argument('--subject', dest='subject', default=None,
                        help='Subject id to process ')
    parser.add_argument('--dir', dest='input_directory',
                        default='.', help='directory containing input file')
    parser.add_argument('--dualcore', dest='multicore',
                        action='store_false', default=True,
                        help='Use 2 cores to process certain steps')
    parser.add_argument('--deidentified', dest="deidentified",
                        action="store_true", default=False,
                        help=argparse.SUPPRESS)
    parser.add_argument('--defaced', dest="defaced",
                        action="store_true", default=False,
                        help=argparse.SUPPRESS)
    # General arguments
    parser.add_argument('--user', dest='user', default=None,
                        help='Username to use to login')
    parser.add_argument('--password', dest='password',
                        default=None, help='Password used to login')

    args = parser.parse_args(sys.argv[1:])

    if args.action in ('status', 'remove', 'output', 'log'):
        if args.workflow_id is None:
            msg = 'ERROR: Use --id to specify a workflow\n'.format(args.action)
            sys.stdout.write(msg)
            sys.exit(3)

    if args.action == 'list':
        username, password = get_user_info(args)
        if args.all_workflows:
            status = list_workflows(username, password, all=True)
        else:
            status = list_workflows(username, password)
    elif args.action == 'remove':
        username, password = get_user_info(args)
        status = remove_workflow(args.workflow_id, username, password)
    elif args.action == 'submit':
        username, password = get_user_info(args)
        status = submit_workflow(username,
                                 password,
                                 args.input_directory,
                                 args.subject,
                                 args.multicore,
                                 args.deidentified,
                                 args.defaced)
    elif args.action == 'output':
        username, password = get_user_info(args)
        status = get_output(args.workflow_id, username, password)
    elif args.action == 'log':
        username, password = get_user_info(args)
        status = get_log(args.workflow_id, username, password)
    elif args.action == 'status':
        username, password = get_user_info(args)
        status = get_status(args.workflow_id, username, password)
    elif args.action == 'change_password':
        username, password = get_user_info(args)
        status = change_password(username, password)
    else:
        sys.stdout.write("Must specify an action, exiting...\n")
        parser.print_help()
        status = 2
    sys.exit(status)

if __name__ == '__main__':
    main()
