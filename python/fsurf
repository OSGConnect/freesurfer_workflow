#!/usr/bin/env python
import argparse
import getpass
import hashlib
import httplib
import json
import os
import sys
import time
import urllib
import urlparse

REST_ENDPOINT = "http://freesurfer.mwt2.org/freesurfer/"


def get_user_info():
    """
    Query user for username and password and return

    :return: username, password
    """
    sys.stdout.write("Enter username: ")
    username = sys.stdin.readline().strip()
    password = getpass.getpass("Enter password: ")
    return username, password


def get_response(query_parameters, noun, method, endpoint=REST_ENDPOINT):
    """
    Query rest endpoint with given  string and return results

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :param method:  HTTP method that should be used
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request(method, "{0}?{1}".format(parsed.path, parsed.query))
        resp = conn.getresponse()
        return resp.status, resp.read()
    except httplib.HTTPException, e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def download_output(query_parameters, noun, endpoint=REST_ENDPOINT):
    """
    Query rest endpoint with given  string and return results

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request('GET', "{0}?{1}".format(parsed.path, parsed.query))
        resp = conn.getresponse()
        if resp.status != 200:
            return resp.status, resp.read()
        with open('fsurf_output.tar.bz2', 'wb') as f:
            temp = resp.read(4096)
            while temp:
                f.write(temp)
                temp = resp.read(4096)
        return resp.status, {'status': 200, 'result': "output downloaded"}
    except httplib.HTTPException, e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def upload_item(query_parameters, noun, body, method, endpoint=REST_ENDPOINT):
    """
    Issue a PUT request to given endpoint

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :param body:  data to be sent in the body
    :param method:  HTTP method that should be used (POST, PUT)
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request(method, "{0}?{1}".format(parsed.path, parsed.query), body)
        resp = conn.getresponse()
        return resp.status, resp.read()
    except httplib.HTTPException, e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def get_token(userid, password):
    """
    Generate an authentication token and timestamp
    :param userid: user id identifying account
    :param password: password for user account
    :return: timestamp, token
    """
    parameters = {'userid': userid, 'id ': 'salt'}
    code, response = get_response(parameters, 'userid/salt', 'GET')
    if code != 200:
        sys.stdout.write("Can't get authentication token\n")
        return None, None
    timestamp = time.time()
    response_obj = json.loads(response)
    salt = response_obj['response']
    token = hashlib.sha256(salt + password).hexdigest()
    token = hashlib.sha256(token + str(timestamp)).hexdigest()
    return str(timestamp), token


def list_workflows():
    """
    List the workflows currently in the system

    :return: 0 on success, 1 on error
    """
    try:
        username, password = get_user_info()
        query_params = {}
        token, datestamp = get_token(username, password)
        if token is None:
            return 1
        query_params['userid'] = username
        query_params['datestamp'] = datestamp
        query_params['token'] = token
        status, response = get_response(query_params, 'job', 'GET')
        if status != 200:
            sys.stdout.write("Error getting workflow information\n")
            return 1
        sys.stdout.write("Current workflows\n")
        response_object = json.loads(response)
        sys.stdout.write("{0:10} {1:20} {2:20} {3:15} {4:10}\n".format('Subject',
                                                                       'Workflow',
                                                                       'Submit time',
                                                                       'Muticore',
                                                                       'Status'))
        for workflow in response_object['jobs']:
            subject = workflow['subject']
            job_id = workflow['name']
            job_time = workflow['time']
            status = workflow['status']
            if not workflow['multicore']:
                cores = 2
            else:
                cores = 8

            sys.stdout.write("{0:10} {1:20} {2:20} {3:15} {4:10}\n".format(subject,
                                                                           job_id,
                                                                           job_time,
                                                                           cores,
                                                                           status))
        return 0
    except IOError:
        return 1


def remove_workflow(workflow_id):
    """
    Stop and remove a specified pegasus workflow

    :param workflow_id: pegasus id for workflow
    :return: 0 on success, 1 on error
    """
    username, password = get_user_info()
    query_params = {}
    token, datestamp = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['datestamp'] = datestamp
    query_params['token'] = token
    query_params['jobid'] = workflow_id
    status, response = get_response(query_params, 'job', 'DELETE')
    if status != 200:
        sys.stdout.write("Error deleting workflow\n")
        return 1
    sys.stdout.write("Workflow removed\n")
    return 0


def submit_workflow(input_directory, subject_name, multicore=False):
    """
    Submit a workflow to OSG for processing

    :param input_directory:    path to file with MRI data in mgz format
    :param subject_name:  name of subject in the file
    :param multicore:     boolean indicating whether to use a multicore workflow or not
    :return:              0 on success, 1 on error
    """
    if subject_name is None:
        sys.stdout.write("Subject name is missing, exiting...\n")
        return 1
    subject_file = os.path.join(input_directory,
                                "{0}_defaced.mgz".format(subject_name))
    subject_file = os.path.abspath(subject_file)
    if not os.path.isfile(subject_file):
        sys.stderr.write("{0} is not present and is needed, exiting".format(subject_file))
        return 1
    with open(subject_file, 'rb') as f:
        body = f.read()
    username, password = get_user_info()
    query_params = {}
    token, timestamp = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['singlecore'] = not multicore
    query_params['subject'] = subject_name
    status, response = upload_item(query_params, 'job', body, 'POST')
    if status != 200:
        sys.stdout.write("Error while submitting workflow\n")
        return 1
    return 0


def get_output(workflow_id):
    """

    :param workflow_id: pegasus id for workflow
    :return: 0 on success, 1 on error
    """
    username, password = get_user_info()
    query_params = {}
    token, datestamp = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['datestamp'] = datestamp
    query_params['token'] = token
    query_params['jobid'] = workflow_id
    status, response = download_output(query_params, 'job/output')
    response_obj = json.loads(response)
    if status != 200:
        sys.stdout.write("Error while downloading results:\n")
        sys.stdout.write("{0}\n".format(response_obj['result']))
        return 1
    sys.stdout.write("Downloaded results to output.tar.bz2")
    return 0


def main():
    """
    Main function that parses arguments and generates the pegasus
    workflow

    :return: True if any errors occurred during DAX generaton
    """
    parser = argparse.ArgumentParser(description="Process freesurfer information")
    parser.add_argument('--submit', dest='action',
                        action='store_const', const='submit',
                        help='Submit job for processing')
    parser.add_argument('--list', dest='action',
                        action='store_const', const='list',
                        help='List current jobs')
    parser.add_argument('--status', dest='action',
                        action='store_const', const='status',
                        help='Submit job for processing')
    parser.add_argument('--remove', dest='action',
                        action='store_const', const='remove',
                        help='Submit job for processing')
    parser.add_argument('--output', dest='action',
                        action='store_const', const='output',
                        help='Submit job for processing')
    parser.add_argument('--workflow-id', dest='workflow_id',
                        action='store', help='Pegasus workflow id to use')
    parser.add_argument('--subject', dest='subject', default=None,
                        help='Subject id to process ')
    parser.add_argument('--input-directory', dest='input_directory',
                        default='.', help='directory containing input file')
    parser.add_argument('--multicore', dest='multicore',
                        action='store_true',
                        help='Use 8 cores to')
    parser.add_argument('--verbose', dest='verbose', default=False,
                        action='store_true',
                        help='Enable verbose output')
    parser.add_argument('--debug', dest='debug', default=False,
                        action='store_true',
                        help='Enable debugging output')
    args = parser.parse_args(sys.argv[1:])

    if args.action == 'list':
        status = list_workflows()
    elif args.action == 'remove':
        status = remove_workflow(args.workflow_id)
    elif args.action == 'submit':
        status = submit_workflow(args.input_directory,
                                 args.subject,
                                 args.multicore)
    elif args.action == 'output':
        status = get_output(args.workflow_id)
    else:
        sys.stdout.write("Must specify an action, exiting...\n")
        parser.print_help()
        status = 0
    sys.exit(status)

if __name__ == '__main__':
    main()
