#!/usr/bin/env python
import argparse
import getpass
import hashlib
import httplib
import json
import os
import sys
import time
import urllib
import urlparse
import re

import cPickle

REST_ENDPOINT = "http://postgres.ci-connect.net/freesurfer"
VERSION = '1.3.11'
CREDENTIAL_FILE = os.path.expanduser('~/.fsurf/credentials')
usage_text = """
|------------------------------------------------------------------------------
| Command       | Function        | Required Switches      | Optional Switches
|---------------|-----------------|------------------------|-------------------
| submit        | Upload and      | --subject [subject]    | --help
|               | process scan    |                        | --user [user name]
|               |                 |                        | --dir [directory]
|               |                 |                        | --dualcore
|               |                 |                        | --defaced
|               |                 |                        | --deidentified
|---------------|-----------------|------------------------|-------------------
| list          | List workflows  |                        | --help
|               |                 |                        | --user [user name]
|               |                 |                        | --all-workflows
|---------------|-----------------|------------------------|-------------------
| status        | Get workflow    | --id [workflow id]     | --help
|               | status          |                        | --user [user name]
|---------------|-----------------|------------------------|-------------------
| output        | Get output from | --id [workflow id]     | --help
|               | completed       |                        | --user [user name]
|               | workflow        |                        | --log-only
|---------------|-----------------|------------------------|-------------------
| remove        | Remove workflow | --id [workflow id]     | --help
|               |                 |                        | --user [user name]
|---------------|-----------------|------------------------|-------------------
|change-password| Change account  |                        | --help
|               | password        |                        | --user [user name]
|------------------------------------------------------------------------------
"""

def error_message(message):
    """
    Print an error message with default message

    :param message: error message to write
    :return: None
    """
    sys.stderr.write("{0}\n".format(message))
    sys.stderr.write("\n\nIf you continue to have problems, please go"
                     "to http://support.opensciencegrid.org/ and open a \n"
                     "support ticket with the fsurf version you're using, "
                     "your username, and a description of the issue\n")


def get_user_credentials():
    """
    Try to get user credentials from a file

    :return: username, password
    """
    if os.path.isfile(CREDENTIAL_FILE):
        with open(CREDENTIAL_FILE, 'rb') as f:
            try:
                pickle = cPickle.load(f)
                if type(pickle) == dict:
                    username = pickle['username']
                    password = pickle['password']
                    return username, password
                else:
                    sys.stdout.write("Credential file is invalid\n")
            except EOFError:
                sys.stdout.write("Credential file is invalid\n")
    return None, None


def save_user_credentials(username, password):
    """
    Try to save user credentials to a file

    :return: None
    """
    if get_user_response('Save credentials? '):
        try:
            cred_dict = {'username': username,
                         'password': password}
            cred_dir = os.path.dirname(CREDENTIAL_FILE)
            if not os.path.exists(cred_dir):
                os.mkdir(cred_dir)
            with open(CREDENTIAL_FILE, 'wb') as f:
                cPickle.dump(cred_dict, f, cPickle.HIGHEST_PROTOCOL)
        except OSError:
            sys.stdout.write("Can't save credentials to {0}\n".format(CREDENTIAL_FILE))
    return


def get_user_info(args):
    """
    Query user for username and password and return

    :param args: argparse object
    :return: username, password
    """
    if not args.user:
        username, password = get_user_credentials()
        if username and password:
            return username, password

    if args.user:
        username = args.user
    else:
        username = raw_input("Enter username: ").strip()

    password = getpass.getpass("Enter password: ")
    save_user_credentials(username, password)
    return username.strip(), password


def get_user_response(prompt, default=None):
    """
    Give a prompt to the user and return a True/False based on user input

    :param prompt: Text to present to user
    :param default: Text to use if user enters a blank response
    :return: True if user said yes, False otherwise
    """
    response = ""
    while response not in ['y', 'n', 'yes', 'no']:
        response = raw_input(prompt)
        response = response.strip().lower()
        if response == "":
            response = default

    if response in ['y', 'yes']:
        return True
    else:
        return False


def get_response(query_parameters, noun, method, endpoint=REST_ENDPOINT):
    """
    Query rest endpoint with given  string and return results

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :param method:  HTTP method that should be used
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.netloc)
        conn.request(method, "{0}?{1}".format(parsed.path, parsed.query))
        resp = conn.getresponse()
        return resp.status, resp.read()
    except IOError as e:  # mainly dns errors
        response = {'status': 500,
                    'result': str(e)}
        return 500, json.dumps(response)
    except httplib.HTTPException as e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def download_output(query_parameters, noun, endpoint=REST_ENDPOINT):
    """
    Query rest endpoint with given  string and return results

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request('GET', "{0}?{1}".format(parsed.path, parsed.query))
        resp = conn.getresponse()
        content_type = resp.getheader('content-type')
        if content_type != 'application/x-bzip2' and \
           content_type != 'text/plain':
            return resp.status, resp.read()
        content_disposition = resp.getheader('content-disposition')
        if content_type == 'application/x-bzip2':
            filename = 'fsurf_output.tar.bz2'
        elif content_type == 'text/plain':
            filename = 'recon-all.log'
        match_obj = re.search(r'filename=(.*)', content_disposition)
        if match_obj:
            filename = match_obj.group(1)
        with open(filename, 'wb') as f:
            temp = resp.read(4096)
            while temp:
                f.write(temp)
                temp = resp.read(4096)
        return resp.status, json.dumps({'status': 200,
                                        'result': "output downloaded",
                                        'filename': filename})
    except httplib.HTTPException as e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def upload_item(query_parameters, noun, body, method, endpoint=REST_ENDPOINT):
    """
    Issue a POST request to given endpoint

    :param endpoint: url to REST endpoint
    :param query_parameters: a dictionary with key, values parameters
    :param noun: object being worked on
    :param body:  data to be sent in the body
    :param method:  HTTP method that should be used (POST, PUT)
    :return: (status code, response from query)
    """
    url = "{0}/{2}?{1}".format(endpoint,
                               urllib.urlencode(query_parameters),
                               noun)
    parsed = urlparse.urlparse(url)
    try:
        conn = httplib.HTTPConnection(parsed.hostname)
        conn.request(method, "{0}?{1}".format(parsed.path, parsed.query), body)
        resp = conn.getresponse()
        return resp.status, resp.read()
    except httplib.HTTPException as e:
        response = {'status': 400,
                    'result': str(e)}
        return 400, json.dumps(response)


def get_token(userid, password):
    """
    Generate an authentication token and timestamp
    :param userid: user id identifying account
    :param password: password for user account
    :return: timestamp, token
    """
    parameters = {'userid': userid}
    code, response = get_response(parameters, 'user/salt', 'GET', REST_ENDPOINT)
    if code == 401:
        error_message("User account disabled\n")
        return None, None
    elif code == 400:
        error_message("Userid not found\n")
        return None, None
    timestamp = time.time()
    response_obj = json.loads(response)
    salt = response_obj['result']
    token = hashlib.sha256(salt + password).hexdigest()
    token = hashlib.sha256(token + str(timestamp)).hexdigest()
    return str(timestamp), token


def list_workflows(args):
    """
    List the workflows currently in the system

    :param args: parsed command line args from argparse
    :return: exits with 0 on success, 1 on error
    """
    try:
        username, password = get_user_info(args)
        query_params = {}
        timestamp, token = get_token(username, password)
        if token is None:
            return 1
        query_params['userid'] = username
        query_params['timestamp'] = timestamp
        query_params['token'] = token
        query_params['all'] = args.all_workflows
        status, response = get_response(query_params, 'job', 'GET')
        if status == 401:
            error_message("Invalid username or password")
            sys.exit(0)
        elif status != 200:
            error_message("Error getting workflow information")
            sys.exit(1)
        sys.stdout.write("Current workflows\n")
        response_object = json.loads(response)
        sys.stdout.write("{0:10} {1:20} {2:27} ".format('Subject',
                                                        'Workflow',
                                                        'Submit time (Central Time)'))
        sys.stdout.write("{0:10} {1:10}\n".format('Cores', 'Status'))
        if len(response_object['jobs']) == 0:
            sys.stdout.write("No workflows in system\n")
        for workflow in response_object['jobs']:
            job_id = workflow[0]
            subject = workflow[1]
            status = workflow[2]
            job_time = workflow[3]
            if not workflow[4]:
                cores = 2
            else:
                cores = 8

            sys.stdout.write("{0:10} {1:<20} {2:<27} ".format(subject,
                                                              job_id,
                                                              job_time))
            sys.stdout.write("{0:<10} {1:10}\n".format(cores,
                                                       status))
        sys.exit(0)
    except IOError:
        sys.exit(1)


def remove_workflow(args):
    """
    Stop and remove a specified pegasus workflow

    :param args: parsed command line args from argparse
    :return: exits with 0 on success, 1 on error
    """
    username, password = get_user_info(args)
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        return 1
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = args.workflow_id
    status, response = get_response(query_params, 'job', 'DELETE')
    resp_dict = json.loads(response)
    if status != 200:
        error_message("Error deleting workflow:\n" +
                      resp_dict['result'])
        return 1
    sys.stdout.write("Workflow removed\n")
    return 0


def submit_workflow(args):
    """
    Submit a workflow to OSG for processing

    :param args: parsed command line args from argparse
    :return: exits with 0 on success, 1 on error
    """
    if args.subject is None:
        sys.stdout.write("Subject name is missing, exiting...\n")
        sys.exit(1)
    if not args.deidentified:
        agree = get_user_response("Has the MRI data been deidentified "
                                  "(This is required) (y/n)? ")
        if not agree:
            sys.stdout.write("MRI data must be deidentified, please "
                             "deidentify the data before submitting\n")
            sys.exit(1)
    if not args.defaced:
        agree = get_user_response("Has the MRI data been defaced "
                                  "(This is recommended) (y/n)? ")
        if not agree:
            sys.stdout.write("We recommend defacing MRI data\n")
            agree = get_user_response("Are you sure you want to submit this "
                                      "file (y/n)?")
            if not agree:
                sys.stdout.write("Aborting submission on user request\n")
                sys.exit(1)
    subject_file = os.path.join(args.input_directory,
                                "{0}_defaced.mgz".format(args.subject))
    subject_file = os.path.abspath(subject_file)
    if not os.path.isfile(subject_file):
        error_message("{0} is not present ".format(subject_file) +
                      "and is needed, exiting")
        sys.exit(1)
    with open(subject_file, 'rb') as f:
        body = f.read()
    query_params = {}
    username, password = get_user_info(args)
    timestamp, token = get_token(username, password)
    if token is None:
        sys.exit(1)
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['multicore'] = args.dualcore
    query_params['subject'] = args.subject
    query_params['jobname'] = "{0}_{1}".format(args.subject, timestamp)
    query_params['filename'] = "{0}_defaced.mgz".format(args.subject)
    sys.stdout.write("Creating and submitting workflow\n")
    status, response = upload_item(query_params, 'job', body, 'POST')
    if status != 200:
        response_obj = json.loads(response)
        error_message("Error while uploading workflow:\n" +
                      response_obj['result'])
        sys.exit(1)
    response_obj = json.loads(response)
    job_id = response_obj['job_id']
    sys.stdout.write("Workflow {0} submitted for processing\n".format(job_id))
    sys.exit(0)


def get_output(args):
    """
    Get output for a completed workflow

    :param args: parsed command line args from argparse
    :return: exits with 0 on success, 1 on error
    """
    username, password = get_user_info(args)
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        sys.exit(1)
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = args.workflow_id
    if args.log_only:
        sys.stdout.write("Downloading logs, this may take a while\n")
        status, response = download_output(query_params, 'job/log')
    else:
        sys.stdout.write("Downloading results, this may take a while\n")
        status, response = download_output(query_params, 'job/output')
    response_obj = json.loads(response)
    if status != 200:
        if args.log_only:
            message = "Error while downloading logs:\n"
        else:
            message = "Error while downloading results:\n"
        message += response_obj['result']
        error_message(message)
        sys.exit(1)
    sys.stdout.write("Downloaded to {0}\n".format(response_obj['filename']))
    if not args.log_only:
        sys.stdout.write("To extract the results: tar "
                         "xvjf {0}\n".format(response_obj['filename']))
    sys.exit(0)


def get_status(args):
    """
    Get status for a workflow

    :param args: parsed command line args from argparse
    :return: exits with 0 on success, 1 on error
    """
    username, password = get_user_info(args)
    query_params = {}
    timestamp, token = get_token(username, password)
    if token is None:
        sys.exit(1)
    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['jobid'] = args.workflow_id
    status, response = get_response(query_params,
                                    'job/status',
                                    'GET')
    response_obj = json.loads(response)
    if status == 404:
        error_message("Workflow with id {0} not found\n".format(args.workflow_id))
        sys.exit(0)
    elif status != 200:
        error_message("Error while getting job status:\n" +
                      "{0}".format(response_obj['result']))
        sys.exit(1)

    sys.stdout.write("{0}\n".format(response_obj['job_status']))
    sys.exit(0)


def change_password(args):
    """
    Change the user's password

    :param args: parsed command line args from argparse
    :return: exits with 0 on success, 1 on error
    """
    query_params = {}
    username, password = get_user_info(args)
    timestamp, token = get_token(username, password)
    if token is None:
        sys.exit(1)
    new_password = getpass.getpass("Enter new password: ")
    password_confirm = getpass.getpass("Re-enter new password: ")
    if new_password != password_confirm:
        sys.stdout.write("Passwords do not match, please try again.\n")
        sys.exit(1)
    salt = hashlib.sha256(str(time.time())).hexdigest()
    pw_hash = hashlib.sha256(salt + new_password).hexdigest()

    query_params['userid'] = username
    query_params['timestamp'] = timestamp
    query_params['token'] = token
    query_params['salt'] = salt
    query_params['pw_hash'] = pw_hash
    status, response = get_response(query_params,
                                    'user/password',
                                    'GET')
    response_obj = json.loads(response)
    if status == 401:
        sys.stdout.write("Invalid username or password\n")
        sys.exit(1)
    elif status == 404:
        sys.stdout.write("User not found\n")
        sys.exit(1)
    elif status != 200:
        sys.stdout.write("Error while changing password:\n")
        sys.stdout.write("{0}\n".format(response_obj['result']))
        sys.exit(1)
    save_user_credentials(username, new_password)
    sys.stdout.write("{0}\n".format(response_obj['result']))
    sys.exit(0)


def main():
    """
    Main function that parses arguments and generates the pegasus
    workflow

    :return: True if any errors occurred during DAX generaton
    """
    parser = argparse.ArgumentParser(description="Process and manage "
                                                 "freesurfer workflows",
                                     usage="%(prog)s {list|status|remove|output|change-password|submit}"
                                           " [options]\n" + usage_text)
    # General arguments
    parser.add_argument('--version', action='version',
                        version='%(prog)s ' + VERSION)
    parser.add_argument('--user', dest='user', default=None,
                        help='Username to use to login')

    subparsers = parser.add_subparsers(title='subcommands',
                                       description='valid actions that can be taken',
                                       help="Command for fsurf")
    # create subparser for list action
    list_parser = subparsers.add_parser('list',
                                        help='List workflows submitted in the '
                                             'last week')
    list_parser.add_argument('--all-workflows',
                             dest='all_workflows',
                             action='store_true',
                             help='List all workflows (instead of just '
                                  'those in the last week)')
    list_parser.add_argument('--user', dest='user', default=None,
                             help='Username to use to login')
    list_parser.set_defaults(func=list_workflows)

    # create subparser for status action
    status_parser = subparsers.add_parser('status',
                                          help='Get status for specified '
                                               'workflow')
    status_parser.add_argument('--id',
                               dest='workflow_id',
                               action='store',
                               type=int,
                               required=True,
                               help='ID for workflow to show')
    status_parser.add_argument('--user', dest='user', default=None,
                               help='Username to use to login')
    status_parser.set_defaults(func=get_status)

    # create subparser for remove action
    remove_parser = subparsers.add_parser('remove',
                                          help='Remove specified workflow')
    remove_parser.add_argument('--id',
                               dest='workflow_id',
                               type=int,
                               required=True,
                               action='store',
                               help='ID for workflow to remove')
    remove_parser.add_argument('--user', dest='user', default=None,
                               help='Username to use to login')
    remove_parser.set_defaults(func=remove_workflow)

    # create subparser for output action
    output_parser = subparsers.add_parser('output',
                                          help='Get output for specified '
                                               'workflow')
    output_parser.add_argument('--id',
                               dest='workflow_id',
                               action='store',
                               type=int,
                               required=True,
                               help='ID for workflow to get output for')
    output_parser.add_argument('--log-only',
                               dest='log_only',
                               action='store_true',
                               help="Only retrieve log file")
    output_parser.add_argument('--user', dest='user', default=None,
                               help='Username to use to login')
    output_parser.set_defaults(func=get_output)

    # create subparser for change password action
    change_parser = subparsers.add_parser('change-password',
                                          help='Change user password')
    change_parser.add_argument('--user', dest='user', default=None,
                               help='Username to use to login')
    change_parser.set_defaults(func=change_password)

    # create subparser for submit action
    submit_parser = subparsers.add_parser('submit',
                                          help='Submit a workflow for '
                                               'processing')
    submit_parser.add_argument('--subject',
                               dest='subject',
                               default=None,
                               help='Subject id to process ')
    submit_parser.add_argument('--dir',
                               dest='input_directory',
                               default='.',
                               help='directory containing input file')
    submit_parser.add_argument('--dualcore',
                               dest='dualcore',
                               action='store_false',
                               default=True,
                               help='Use 2 cores to process all steps')
    submit_parser.add_argument('--deidentified',
                               dest="deidentified",
                               action="store_true",
                               help=argparse.SUPPRESS)
    submit_parser.add_argument('--defaced',
                               dest="defaced",
                               action="store_true",
                               help=argparse.SUPPRESS)
    submit_parser.add_argument('--user', dest='user', default=None,
                               help='Username to use to login')
    # submit_parser.add_argument('--input-file',
    #                            dest='input_file',
    #                            default='.',
    #                            help='name of  input file(s), this can be used '
    #                                 'multiple times')
    # submit_parser.add_argument('--subject-dir',
    #                            dest='subject_dir',
    #                            default='.',
    #                            help='name of zip file with subject directory '
    #                                 'to use')
    submit_parser.set_defaults(func=submit_workflow)

    args = parser.parse_args(sys.argv[1:])
    args.func(args)

if __name__ == '__main__':
    main()
